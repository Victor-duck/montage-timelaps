import React, { useState, useMemo } from 'react';
import { 
  Dna, 
  Plus, 
  Trash2, 
  FileText, 
  Settings, 
  ChevronDown, 
  ChevronRight, 
  Database, 
  ScanSearch
} from 'lucide-react';

// --- Fonctions Utilitaires ---

// Nettoyage et parsing du format FASTA
const parseFasta = (text) => {
  if (!text) return [];
  const lines = text.split('\n');
  const sequences = [];
  let currentHeader = '';
  let currentSeq = '';

  lines.forEach((line) => {
    const trimmed = line.trim();
    if (trimmed.startsWith('>')) {
      if (currentHeader) {
        sequences.push({
          id: Math.random().toString(36).substr(2, 9),
          header: currentHeader.substring(1),
          sequence: currentSeq.toUpperCase().replace(/[^A-Z]/g, '')
        });
      }
      currentHeader = trimmed;
      currentSeq = '';
    } else {
      currentSeq += trimmed;
    }
  });

  if (currentHeader) {
    sequences.push({
      id: Math.random().toString(36).substr(2, 9),
      header: currentHeader.substring(1),
      sequence: currentSeq.toUpperCase().replace(/[^A-Z]/g, '')
    });
  }

  return sequences;
};

// Algorithme "Best Fit" pour trouver la meilleure correspondance (avec mutations)
const findBestMatch = (seq, pattern) => {
  if (seq.length < pattern.length) return null;
  
  let bestIndex = -1;
  let minMismatches = pattern.length + 1;
  
  // Fenêtre glissante
  for (let i = 0; i <= seq.length - pattern.length; i++) {
    let mismatches = 0;
    // Optimisation: arrêt si pire que le meilleur score actuel
    for (let j = 0; j < pattern.length; j++) {
      if (seq[i+j] !== pattern[j]) {
        mismatches++;
      }
      if (mismatches > minMismatches) break;
    }
    
    if (mismatches < minMismatches) {
      minMismatches = mismatches;
      bestIndex = i;
    }
  }

  // Score de similarité (0 à 1)
  const similarity = 1 - (minMismatches / pattern.length);
  
  // Seuil de tolérance (65% minimum)
  if (similarity < 0.65) return null;

  return { index: bestIndex, mismatches: minMismatches, similarity };
};

const COLORS = [
  { label: 'Bleu', bg: 'bg-blue-100', text: 'text-blue-800', border: 'border-blue-300', hex: '#dbeafe' },
  { label: 'Vert', bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300', hex: '#dcfce7' },
  { label: 'Ambre', bg: 'bg-amber-100', text: 'text-amber-800', border: 'border-amber-300', hex: '#fef3c7' },
  { label: 'Rose', bg: 'bg-rose-100', text: 'text-rose-800', border: 'border-rose-300', hex: '#ffe4e6' },
  { label: 'Violet', bg: 'bg-purple-100', text: 'text-purple-800', border: 'border-purple-300', hex: '#f3e8ff' },
  { label: 'Gris', bg: 'bg-gray-200', text: 'text-gray-800', border: 'border-gray-400', hex: '#e5e7eb' },
];

const App = () => {
  // --- État ---
  const [inputText, setInputText] = useState('');
  const [sequences, setSequences] = useState([]);
  const [rules, setRules] = useState([]); 
  
  // Formulaire Nouvelle Règle
  const [newRuleType, setNewRuleType] = useState('sequence');
  const [newRuleName, setNewRuleName] = useState('');
  const [newRuleValue, setNewRuleValue] = useState('');
  const [newRuleColor, setNewRuleColor] = useState(COLORS[0]);
  const [allowMutations, setAllowMutations] = useState(false);

  // --- Gestionnaires ---

  const handleFastaInput = (e) => {
    const text = e.target.value;
    setInputText(text);
    const parsed = parseFasta(text);
    setSequences(parsed);
  };

  const addRule = () => {
    if (!newRuleName || !newRuleValue) return;

    let parsedValue = newRuleValue;
    
    if (newRuleType === 'range') {
      const parts = newRuleValue.split('-').map(n => parseInt(n.trim()));
      if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) {
        alert("Format de plage invalide. Utilisez 'début-fin' (ex: 1-20)");
        return;
      }
      parsedValue = { start: parts[0], end: parts[1] };
    } else {
      parsedValue = newRuleValue.toUpperCase().replace(/[^A-Z]/g, '');
    }

    const newRule = {
      id: Date.now(),
      name: newRuleName,
      type: newRuleType,
      value: parsedValue,
      color: newRuleColor,
      active: true,
      allowMutations: newRuleType === 'sequence' ? allowMutations : false
    };

    setRules([...rules, newRule]);
    // Reset partiel pour enchainer
    setNewRuleName('');
    setNewRuleValue('');
  };

  const removeRule = (id) => {
    setRules(rules.filter(r => r.id !== id));
  };

  const toggleRule = (id) => {
    setRules(rules.map(r => r.id === id ? { ...r, active: !r.active } : r));
  };

  // --- Moteur d'Annotation ---

  const getAnnotatedSegments = (seqStr, activeRules) => {
    const len = seqStr.length;
    // Masque : chaque index contient la règle qui s'applique + info mutation
    const mask = new Array(len).fill(null);

    activeRules.forEach(rule => {
      if (rule.type === 'range') {
        const start = Math.max(0, rule.value.start - 1);
        const end = Math.min(len, rule.value.end);
        for (let i = start; i < end; i++) {
          mask[i] = { rule, meta: 'Position' };
        }
      } 
      else if (rule.type === 'sequence') {
        const query = rule.value;
        if (!query) return;
        
        if (rule.allowMutations) {
          // Logique Floue (Mutations)
          const bestFit = findBestMatch(seqStr, query);
          if (bestFit) {
            const start = bestFit.index;
            const end = bestFit.index + query.length;
            const percent = Math.round(bestFit.similarity * 100);
            
            for (let i = start; i < end; i++) {
              mask[i] = { 
                rule, 
                meta: `${percent}% Id.`, 
                refIndex: i - start // Index relatif pour afficher la base de référence
              };
            }
          }
        } else {
          // Logique Exacte
          let pos = seqStr.indexOf(query);
          while (pos !== -1) {
            for (let i = pos; i < pos + query.length; i++) {
              mask[i] = { rule, meta: '100%' };
            }
            pos = seqStr.indexOf(query, pos + 1);
          }
        }
      }
    });

    // Conversion masque -> segments pour affichage
    const segments = [];
    if (len === 0) return segments;

    let current = mask[0];
    let currentText = seqStr[0];

    for (let i = 1; i < len; i++) {
      // On groupe tant que c'est la même règle (même ID)
      const sameRule = (current === null && mask[i] === null) || 
                       (current && mask[i] && current.rule.id === mask[i].rule.id);
                       
      if (sameRule) {
        currentText += seqStr[i];
      } else {
        segments.push({ text: currentText, data: current });
        currentText = seqStr[i];
        current = mask[i]; 
      }
    }
    segments.push({ text: currentText, data: current });
    return segments;
  };

  const processedSequences = useMemo(() => {
    const activeRules = rules.filter(r => r.active);
    
    return sequences.map(seq => {
      const segments = getAnnotatedSegments(seq.sequence, activeRules);
      const matchedRules = new Set(segments.filter(s => s.data).map(s => s.data.rule.name));
      
      return {
        ...seq,
        segments,
        matchCount: matchedRules.size
      };
    });
  }, [sequences, rules]);

  // --- Données de test ---
  const loadSample = () => {
    const sample = `>IgG1_Heavy_Chain_Mutated_Sample
ATGGGATGGAGCTGTATCATCCTCTTCTTGGTAGCAACAGCTACAGGTGTCCACTCCGAGGTGCAGCTGGTGGAGTCTGG
GGGAGGCCTGGTCAAGCCTGGGGGGTCCCTGAGACTCTCCTGTGCAGCCTCTGGATTCACCTTCAGTAGCTATAGCATGA
ACTGGGTCCGCCAGGCTCCAGGGAAGGGGCTGGAGTGGGTCTCATCCATTAGTAGTAGTAGTAGTTACATATACTACGCA
GACTCAGTGAAGGGCCGATTCACCATCTCCAGAGACAACGCCAAGAACTCACTGTATCTGCAAATGAACAGCCTGAGAGC
CGAGGACACGGCTGTGTATTACTGTGCGAGAGATCCCCCCTATAGCAGCAGCTGGTACGACTGCTTTGATATCTGGGGCC`;
    setInputText(sample);
    setSequences(parseFasta(sample));
    
    setRules([
      // Exemple avec mutation volontaire dans la référence
      { 
        id: 1, 
        name: 'Leader (Muté)', 
        type: 'sequence', 
        value: 'ATGGGATGGAGCTCTATCATCCTCTTCTTCCTAGCAACAGCTACAGGTGTCCACTCC', // "C" au lieu de "G" à qqs endroits
        color: COLORS[0], 
        active: true,
        allowMutations: true 
      },
      { id: 2, name: 'Region Variable', type: 'range', value: { start: 60, end: 150 }, color: COLORS[1], active: true, allowMutations: false },
    ]);
  };

  return (
    <div className="min-h-screen bg-gray-50 text-gray-800 font-sans">
      {/* Header */}
      <header className="bg-white border-b border-gray-200 sticky top-0 z-30">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Dna className="text-indigo-600 w-6 h-6" />
            <h1 className="text-xl font-bold text-gray-900">IgG Annotator <span className="text-xs font-normal text-gray-500 bg-gray-100 px-2 py-1 rounded-full">Simple Mode</span></h1>
          </div>
          <div className="flex gap-2">
            <button onClick={loadSample} className="text-sm text-indigo-600 hover:text-indigo-800 font-medium px-3 py-1 rounded hover:bg-indigo-50 transition-colors">
              Charger Exemple
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
          
          {/* COLONNE GAUCHE : Entrées & Règles */}
          <div className="lg:col-span-4 space-y-6">
            
            {/* Zone FASTA */}
            <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
              <div className="px-4 py-3 bg-gray-50 border-b border-gray-200 flex justify-between items-center">
                <h2 className="font-semibold text-gray-700 flex items-center gap-2">
                  <Database size={16} /> Entrée FASTA
                </h2>
                <span className="text-xs text-gray-500">{sequences.length} séquences</span>
              </div>
              <div className="p-4">
                <textarea
                  className="w-full h-48 p-3 text-xs font-mono border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none resize-none"
                  placeholder=">Seq1&#10;ATGC...&#10;>Seq2&#10;CCGT..."
                  value={inputText}
                  onChange={handleFastaInput}
                ></textarea>
                <p className="text-xs text-gray-400 mt-2">Collez plusieurs séquences au format FASTA.</p>
              </div>
            </div>

            {/* Gestionnaire de Règles */}
            <div className="bg-white rounded-xl shadow-sm border border-gray-200">
              <div className="px-4 py-3 bg-gray-50 border-b border-gray-200">
                <h2 className="font-semibold text-gray-700 flex items-center gap-2">
                  <Settings size={16} /> Règles d'annotation
                </h2>
              </div>
              
              {/* Formulaire Ajout */}
              <div className="p-4 border-b border-gray-100 bg-gray-50/50">
                <h3 className="text-xs font-bold text-gray-500 uppercase mb-3">Ajouter une règle</h3>
                <div className="space-y-3">
                  <div className="flex gap-2">
                    <select 
                      value={newRuleType}
                      onChange={(e) => setNewRuleType(e.target.value)}
                      className="text-sm border border-gray-300 rounded-md px-2 py-1.5 focus:ring-1 focus:ring-indigo-500"
                    >
                      <option value="sequence">Séquence (Motif)</option>
                      <option value="range">Position (Plage)</option>
                    </select>
                    <input
                      type="text"
                      placeholder="Nom (ex: Leader)"
                      className="flex-1 text-sm border border-gray-300 rounded-md px-3 py-1.5 focus:ring-1 focus:ring-indigo-500 outline-none"
                      value={newRuleName}
                      onChange={(e) => setNewRuleName(e.target.value)}
                    />
                  </div>

                  <div className="flex gap-2">
                    <input
                      type="text"
                      placeholder={newRuleType === 'sequence' ? "ATGC..." : "1-100"}
                      className="flex-1 font-mono text-sm border border-gray-300 rounded-md px-3 py-1.5 focus:ring-1 focus:ring-indigo-500 outline-none uppercase"
                      value={newRuleValue}
                      onChange={(e) => setNewRuleValue(e.target.value)}
                    />
                  </div>

                  {/* Case à cocher Mutations */}
                  {newRuleType === 'sequence' && (
                    <div className="flex items-center gap-2 px-1">
                      <input 
                        type="checkbox" 
                        id="allowMutations"
                        checked={allowMutations}
                        onChange={(e) => setAllowMutations(e.target.checked)}
                        className="rounded text-indigo-600 focus:ring-indigo-500 h-4 w-4"
                      />
                      <label htmlFor="allowMutations" className="text-xs text-gray-600 cursor-pointer flex items-center gap-1">
                        <ScanSearch size={12} />
                        Autoriser mutations (Best Fit)
                      </label>
                    </div>
                  )}

                  <div className="flex justify-between items-center pt-2">
                    <div className="flex gap-1">
                      {COLORS.map((c) => (
                        <button
                          key={c.label}
                          onClick={() => setNewRuleColor(c)}
                          className={`w-6 h-6 rounded-full border ${c.bg} ${newRuleColor.label === c.label ? 'ring-2 ring-offset-1 ring-indigo-500 border-indigo-400' : 'border-gray-200'}`}
                          title={c.label}
                        />
                      ))}
                    </div>
                    <button 
                      onClick={addRule}
                      disabled={!newRuleName || !newRuleValue}
                      className="bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed text-white text-sm px-3 py-1.5 rounded-md flex items-center gap-1 transition-colors"
                    >
                      <Plus size={14} /> Ajouter
                    </button>
                  </div>
                </div>
              </div>

              {/* Liste des Règles */}
              <div className="max-h-60 overflow-y-auto p-2">
                {rules.length === 0 ? (
                  <div className="text-center py-6 text-gray-400 text-sm">
                    Aucune règle définie
                  </div>
                ) : (
                  <div className="space-y-2">
                    {rules.map(rule => (
                      <div key={rule.id} className={`flex items-center justify-between p-2 rounded-lg border ${rule.active ? 'bg-white border-gray-200' : 'bg-gray-50 border-gray-100 opacity-60'}`}>
                        <div className="flex items-center gap-3 overflow-hidden">
                          <input 
                            type="checkbox" 
                            checked={rule.active} 
                            onChange={() => toggleRule(rule.id)}
                            className="rounded text-indigo-600 focus:ring-indigo-500 h-4 w-4"
                          />
                          <div className={`w-3 h-3 rounded-full flex-shrink-0 ${rule.color.bg} border ${rule.color.border}`}></div>
                          <div className="min-w-0">
                            <p className="text-sm font-medium text-gray-700 truncate flex items-center gap-2">
                              {rule.name}
                              {rule.allowMutations && <ScanSearch size={12} className="text-indigo-500" title="Mutations activées" />}
                            </p>
                            <p className="text-xs text-gray-500 truncate font-mono">
                              {rule.type === 'range' ? `Pos: ${rule.value.start}-${rule.value.end}` : rule.value.slice(0,15)+'...'}
                            </p>
                          </div>
                        </div>
                        <button onClick={() => removeRule(rule.id)} className="text-gray-400 hover:text-red-500 p-1">
                          <Trash2 size={14} />
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>

          </div>

          {/* COLONNE DROITE : Résultats */}
          <div className="lg:col-span-8">
            <div className="bg-white rounded-xl shadow-sm border border-gray-200 min-h-[600px] flex flex-col">
              <div className="px-6 py-4 border-b border-gray-200 flex justify-between items-center bg-gray-50 rounded-t-xl">
                <h2 className="font-semibold text-gray-800 flex items-center gap-2">
                  <FileText size={18} /> Résultats ({sequences.length})
                </h2>
              </div>

              <div className="flex-1 p-6 overflow-y-auto bg-slate-50">
                {processedSequences.length === 0 ? (
                  <div className="h-full flex flex-col items-center justify-center text-gray-400 space-y-4">
                    <Dna size={64} className="opacity-20" />
                    <p>Entrez des séquences FASTA pour commencer l'analyse.</p>
                  </div>
                ) : (
                  <div className="space-y-6">
                    {processedSequences.map((seq) => (
                      <SequenceViewer 
                        key={seq.id} 
                        sequenceData={seq} 
                      />
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>

        </div>
      </main>
    </div>
  );
};

// Composant d'affichage d'une séquence
const SequenceViewer = ({ sequenceData }) => {
  const [isExpanded, setIsExpanded] = useState(true);

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden transition-all duration-200">
      <div 
        className="px-4 py-3 bg-white border-b border-gray-100 flex items-center justify-between cursor-pointer hover:bg-gray-50"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-2">
          {isExpanded ? <ChevronDown size={16} className="text-gray-400"/> : <ChevronRight size={16} className="text-gray-400"/>}
          <h3 className="font-mono text-sm font-bold text-gray-700 truncate max-w-md">{sequenceData.header}</h3>
          <span className="text-xs px-2 py-0.5 bg-gray-100 text-gray-500 rounded-full">
            {sequenceData.sequence.length} pb
          </span>
        </div>
        
        <div className="flex items-center gap-4">
           {sequenceData.matchCount > 0 && (
             <span className="text-xs text-indigo-600 font-medium flex items-center gap-1">
               <div className="w-2 h-2 bg-indigo-500 rounded-full animate-pulse"></div>
               {sequenceData.matchCount} annotations
             </span>
           )}
        </div>
      </div>

      {isExpanded && (
        <div className="p-4 overflow-x-auto">
          {/* VISUALISATION : 
             - leading-[3.5rem] : Grand interligne pour l'affichage vertical (ADN + Ref)
             - break-all : Pour éviter les sauts de ligne intempestifs
          */}
          <div className="font-mono text-xs leading-[3.5rem] break-all tracking-widest text-gray-400 select-text">
            {sequenceData.segments.map((seg, idx) => {
              if (seg.data) {
                // CAS 1 : VUE DÉTAILLÉE (Mutations)
                if (seg.data.rule.allowMutations && typeof seg.data.refIndex === 'number') {
                   const refSequence = seg.data.rule.value;
                   
                   // Conteneur principal (couleur de fond de l'annotation)
                   return (
                     <span 
                      key={idx}
                      className={`
                        ${seg.data.rule.color.bg} ${seg.data.rule.color.text} 
                        border-y-2 ${seg.data.rule.color.border}
                        py-1 relative group cursor-help inline decoration-clone box-decoration-clone
                      `}
                     >
                       {seg.text.split('').map((char, i) => {
                         // Comparaison char vs ref
                         const refChar = refSequence[seg.data.refIndex + i] || '?';
                         const isMismatch = char !== refChar;
                         
                         // Pile verticale : 
                         // - Haut : Nucléotide réel (Rouge si différent)
                         // - Bas : Nucléotide de référence (Gris/Indigo)
                         return (
                           <span key={i} className="inline-flex flex-col items-center justify-start mx-[0.5px] align-middle -my-3 h-8">
                             {/* La séquence */}
                             <span className={`h-4 leading-4 flex items-center ${isMismatch ? "font-extrabold text-red-600" : ""}`}>{char}</span>
                             
                             {/* La référence (sous-titre) */}
                             <span className={`h-4 leading-4 flex items-center text-[0.7em] font-bold select-none pointer-events-none ${isMismatch ? 'text-indigo-600' : 'text-gray-500 opacity-60'}`}>
                               {refChar}
                             </span>
                           </span>
                         )
                       })}
                       
                       {/* Tooltip */}
                        <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1 px-2 py-1 bg-gray-800 text-white text-[10px] rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none z-10 font-sans shadow-lg font-normal">
                          {seg.data.rule.name}
                        </span>
                     </span>
                   );
                }

                // CAS 2 : ANNOTATION STANDARD (Sans détails de mutation)
                return (
                  <span 
                    key={idx} 
                    className={`
                      ${seg.data.rule.color.bg} ${seg.data.rule.color.text} 
                      border-y-2 ${seg.data.rule.color.border}
                      py-1 relative group font-bold select-all cursor-help inline decoration-clone box-decoration-clone align-middle
                    `}
                  >
                    {seg.text}
                    <span className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1 px-2 py-1 bg-gray-800 text-white text-[10px] rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none z-10 font-sans shadow-lg">
                      {seg.data.rule.name}
                    </span>
                  </span>
                );
              }
              
              // Texte standard non annoté
              return <span key={idx} className="text-gray-600 inline align-middle">{seg.text}</span>;
            })}
          </div>
        </div>
      )}
    </div>
  );
};

export default App;
