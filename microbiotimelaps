import React, { useState, useEffect, useRef } from 'react';

// Icônes SVG
const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
const IconFilm = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="7" y1="3" x2="7" y2="21"/><line x1="17" y1="3" x2="17" y2="21"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="7" x2="7" y2="7"/><line x1="2" y1="17" x2="7" y2="17"/><line x1="17" y1="17" x2="22" y2="17"/><line x1="17" y1="7" x2="22" y2="7"/></svg>;
const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>;
const IconGrid = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>;
const IconArrowLeft = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 18l-6-6 6-6"/></svg>;
const IconArrowRight = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>;
const IconInfo = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>;

export default function App() {
    const [files, setFiles] = useState([]);
    const [groups, setGroups] = useState({});
    const [processing, setProcessing] = useState(false);
    
    const isProcessingRef = useRef(false);

    const [dragActive, setDragActive] = useState(false);
    const [progress, setProgress] = useState({ current: 0, total: 0, status: '' });
    
    const [fps, setFps] = useState(10);
    const [showTimestamp, setShowTimestamp] = useState(true);

    const [selectedGroups, setSelectedGroups] = useState([]);
    const [customLabels, setCustomLabels] = useState({});

    // --- GESTION DES FICHIERS ---
    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (e.type === "dragenter" || e.type === "dragover") setDragActive(true); else if (e.type === "dragleave") setDragActive(false); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setDragActive(false); if (e.dataTransfer.files && e.dataTransfer.files[0]) processFiles(e.dataTransfer.files); };
    const handleChange = (e) => { if (e.target.files && e.target.files[0]) processFiles(e.target.files); };

    const processFiles = (fileList) => {
        const newFiles = Array.from(fileList);
        const validImages = newFiles.filter(f => f.type.startsWith('image/') || f.name.toLowerCase().endsWith('.tif') || f.name.toLowerCase().endsWith('.tiff'));
        if (validImages.length === 0) return;
        setFiles(prev => [...prev, ...validImages]);
    };

    // --- ALGORITHME DE REGROUPEMENT ---
    useEffect(() => {
        const newGroups = {};
        const regex = /^(.*?)_20\d{2}y/;
        files.forEach(file => {
            const match = file.name.match(regex);
            let groupName = match && match[1] ? match[1] : "Autres";
            if (!newGroups[groupName]) newGroups[groupName] = [];
            newGroups[groupName].push(file);
        });
        Object.keys(newGroups).forEach(key => { newGroups[key].sort((a, b) => a.name.localeCompare(b.name)); });
        setGroups(newGroups);
    }, [files]);

    const toggleSelection = (groupName) => {
        setSelectedGroups(prev => prev.includes(groupName) ? prev.filter(n => n !== groupName) : [...prev, groupName]);
        if (!customLabels[groupName]) setCustomLabels(prev => ({ ...prev, [groupName]: groupName }));
    };
    const handleLabelChange = (groupName, newLabel) => { setCustomLabels(prev => ({ ...prev, [groupName]: newLabel })); };
    const moveGroup = (index, direction) => {
        const newGroups = [...selectedGroups];
        const newIndex = index + direction;
        if (newIndex >= 0 && newIndex < newGroups.length) {
            [newGroups[index], newGroups[newIndex]] = [newGroups[newIndex], newGroups[index]];
            setSelectedGroups(newGroups);
        }
    };

    const loadImage = (file) => {
        return new Promise((resolve, reject) => {
            if (file.type === 'image/tiff' || file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
                reject(new Error(`Le fichier "${file.name}" est un TIFF. Les navigateurs ne lisent pas ce format.`));
                return;
            }
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => resolve({ img, url });
            img.onerror = () => reject(new Error(`Impossible de lire l'image "${file.name}".`));
            img.src = url;
        });
    };
    const makeEven = (n) => n % 2 === 0 ? n : n - 1;

    const startProcessing = (name) => {
        setProcessing(name);
        isProcessingRef.current = true;
    };

    const stopProcessing = () => {
        setProcessing(false);
        isProcessingRef.current = false;
    };

    // --- MOTEUR D'ENREGISTREMENT OPTIMISÉ (NO FLASH) ---
    const recordCanvasStream = async (canvas, ctx, totalFrames, getFrameConfig, fileName) => {
        const overlay = document.createElement('div');
        Object.assign(overlay.style, {
            position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
            backgroundColor: 'rgba(255, 255, 255, 0.98)', zIndex: '99999',
            display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', pointerEvents: 'all'
        });

        const message = document.createElement('div');
        message.innerHTML = `<h2 style="margin-bottom:10px">Génération en cours...</h2><p style="color:#666">Ne quittez pas cette fenêtre.</p>`;
        message.style.textAlign = "center";
        
        canvas.style.maxWidth = '80vw';
        canvas.style.maxHeight = '60vh';
        canvas.style.border = '1px solid #333'; // Bordure sombre pour visualiser le cadre
        canvas.style.backgroundColor = '#000'; // Fond noir dans l'aperçu
        
        overlay.appendChild(message);
        overlay.appendChild(canvas);
        document.body.appendChild(overlay);

        let mimeType = 'video/webm'; 
        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) mimeType = 'video/webm;codecs=vp8';

        let mediaRecorder;
        let chunks = [];

        try {
            const stream = canvas.captureStream(fps);
            mediaRecorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 5000000 });
        } catch (e) {
            alert(`Erreur d'initialisation : ${e.message}`);
            stopProcessing();
            document.body.removeChild(overlay);
            return;
        }

        mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };

        const recordingPromise = new Promise((resolve, reject) => {
            mediaRecorder.onstop = () => {
                try {
                    const blob = new Blob(chunks, { type: mimeType });
                    if (blob.size === 0) throw new Error("Fichier vide généré.");
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    resolve();
                } catch (err) { reject(err); }
            };
            mediaRecorder.onerror = (e) => reject(e);
        });

        await new Promise(r => requestAnimationFrame(r)); 
        mediaRecorder.start();

        let successCount = 0;

        try {
            for (let i = 0; i < totalFrames; i++) {
                if (!isProcessingRef.current) break;

                setProgress({ current: i + 1, total: totalFrames, status: `Préparation frame ${i + 1}/${totalFrames}` });

                // 1. Récupérer la config de la frame (quels fichiers, quelles positions)
                const frameConfig = getFrameConfig(i);

                // 2. PRÉ-CHARGEMENT : Charger TOUTES les images de cette frame EN PARALLÈLE
                // On ne touche pas au canvas tant que tout n'est pas chargé -> Élimine les flashs blancs
                const loadedImages = await Promise.all(frameConfig.map(async (item) => {
                    try {
                        const { img, url } = await loadImage(item.file);
                        return { ...item, img, url, success: true };
                    } catch (e) {
                        console.error(e);
                        return { ...item, success: false };
                    }
                }));

                // 3. DESSIN SYNCHRONE : Une fois tout chargé, on dessine tout d'un coup
                // Fond noir pour les séparations
                ctx.fillStyle = "#000000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                loadedImages.forEach(item => {
                    if (item.success) {
                        // Dessin image
                        ctx.drawImage(item.img, item.x, item.y, item.w, item.h);
                        
                        // Dessin Titre/Label (Fond gris foncé, texte blanc)
                        if (item.label) {
                            const headerH = 50; // Hauteur bandeau
                            ctx.fillStyle = "#1f2937"; 
                            ctx.fillRect(item.x, item.y - headerH, item.w, headerH);
                            ctx.fillStyle = "#ffffff";
                            ctx.font = `bold ${Math.max(16, item.w / 25)}px Arial`; 
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(item.label, item.x + (item.w / 2), item.y - (headerH / 2));
                        }

                        // Dessin Timestamp individuel (optionnel)
                        if (item.overlayText) {
                             ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                             ctx.fillRect(item.x, item.y + item.h - 40, item.w, 40);
                             ctx.fillStyle = "white"; ctx.font = "20px Arial";
                             ctx.textAlign = "left";
                             ctx.fillText(item.overlayText, item.x + 10, item.y + item.h - 10);
                        }

                        // Nettoyage mémoire
                        URL.revokeObjectURL(item.url);
                        successCount++;
                    }
                });

                // Pause pour le FPS
                await new Promise(r => setTimeout(r, 1000 / fps));
            }

            if (isProcessingRef.current && successCount > 0) {
                await new Promise(r => setTimeout(r, 500));
                if (mediaRecorder.state !== 'inactive') mediaRecorder.stop();
                await recordingPromise;
            } else if (successCount === 0) {
                throw new Error("Aucune image traitée.");
            }

        } catch (e) {
            alert("Erreur : " + e.message);
        } finally {
            if(document.body.contains(overlay)) document.body.removeChild(overlay);
            stopProcessing();
        }
    };

    // --- GÉNÉRATEURS ---

    const generateComparison = async () => {
        if (selectedGroups.length === 0) return;
        const compositeName = "Comparaison_" + selectedGroups.length + "_puits";
        startProcessing(compositeName);
        
        const activeGroupsData = selectedGroups.map(name => ({
            name, files: groups[name], label: customLabels[name] || name
        }));

        const count = activeGroupsData.length;
        let cols = Math.ceil(Math.sqrt(count));
        if (count === 2) cols = 2;
        const rows = Math.ceil(count / cols);
        
        const headerHeight = 50; 
        const gap = 4; // ÉPAISSEUR DU TRAIT NOIR DE SÉPARATION

        let singleW, singleH;
        try {
            const { img, url } = await loadImage(activeGroupsData[0].files[0]);
            singleW = makeEven(img.width);
            singleH = makeEven(img.height);
            URL.revokeObjectURL(url);
        } catch (e) { alert(e.message); stopProcessing(); return; }

        const canvas = document.createElement('canvas');
        // Calcul taille totale avec les gaps
        canvas.width = (singleW * cols) + (gap * (cols - 1));
        canvas.height = ((singleH + headerHeight) * rows) + (gap * (rows - 1)); 
        const ctx = canvas.getContext('2d');

        // Nouvelle fonction qui retourne juste la config sans dessiner
        const getFrameConfig = (frameIndex) => {
            return activeGroupsData.map((group, idx) => {
                const col = idx % cols;
                const row = Math.floor(idx / cols);
                
                // Calcul position avec gap
                const x = col * (singleW + gap);
                const y = row * (singleH + headerHeight + gap) + headerHeight; // +headerHeight car l'image est sous le titre

                const fileIndex = Math.min(frameIndex, group.files.length - 1);
                return { 
                    file: group.files[fileIndex], 
                    x, y, w: singleW, h: singleH, 
                    label: group.label // On passe le label pour qu'il soit dessiné
                };
            });
        };

        const maxFrames = Math.max(...activeGroupsData.map(g => g.files.length));
        await recordCanvasStream(canvas, ctx, maxFrames, getFrameConfig, compositeName);
    };

    const generateSingle = async (groupName) => {
        startProcessing(groupName);
        const files = groups[groupName];
        
        let w, h;
        try {
            const { img, url } = await loadImage(files[0]);
            w = makeEven(img.width); h = makeEven(img.height);
            URL.revokeObjectURL(url);
        } catch (e) { alert(e.message); stopProcessing(); return; }

        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');

        const getFrameConfig = (i) => {
            const file = files[i];
            const overlay = showTimestamp ? file.name.split('.')[0] : null;
            return [{ file, x: 0, y: 0, w: w, h: h, overlayText: overlay }];
        };

        await recordCanvasStream(canvas, ctx, files.length, getFrameConfig, groupName);
    };

    const clearAll = () => { setFiles([]); setGroups({}); setSelectedGroups([]); setCustomLabels({}); };

    return (
        <div className="min-h-screen bg-gray-100 pb-48 font-sans relative">
            <style>{`.drop-zone { transition: all 0.2s ease; border-style: dashed; } .drop-zone.active { border-color: #3b82f6; background-color: #eff6ff; }`}</style>

            <div className="max-w-6xl mx-auto p-8">
                <header className="mb-8">
                    <h1 className="text-3xl font-bold text-gray-800 flex items-center gap-3"><IconFilm /> MicroTime Lapse</h1>
                    <p className="text-gray-600 mt-2">Générez des timelapses individuels ou comparez vos conditions expérimentales.</p>
                </header>

                <div className="bg-white p-6 rounded-xl shadow-sm mb-6 flex gap-6 items-center flex-wrap">
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Vitesse (FPS)</label>
                        <input type="number" min="1" max="60" value={fps} onChange={(e) => setFps(Number(e.target.value))} className="border rounded px-3 py-1 w-20"/>
                    </div>
                    <div className="flex items-center gap-2 mt-5">
                        <input type="checkbox" id="ts" checked={showTimestamp} onChange={(e) => setShowTimestamp(e.target.checked)} className="h-4 w-4 text-blue-600 rounded"/>
                        <label htmlFor="ts" className="text-sm text-gray-700">Incruster timestamp (vidéo simple)</label>
                    </div>
                    <div className="flex items-center gap-2 mt-5 ml-auto text-xs text-orange-600 bg-orange-50 px-3 py-1 rounded border border-orange-200">
                        <IconInfo /> 
                        <span className="ml-1">
                            Important: Utilisez <b>VLC</b> pour lire les vidéos WebM. Les flashs blancs ont été corrigés.
                        </span>
                    </div>
                </div>

                <div 
                    className={`drop-zone p-10 rounded-2xl border-2 text-center cursor-pointer mb-8 ${dragActive ? 'active border-blue-500' : 'border-gray-300 bg-white'}`}
                    onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                    onClick={() => document.getElementById('fileInput').click()}
                >
                    <input id="fileInput" type="file" multiple accept="image/*" className="hidden" onChange={handleChange} />
                    <div className="flex flex-col items-center gap-4">
                        <div className="bg-blue-50 p-4 rounded-full text-blue-500"><IconUpload /></div>
                        <div>
                            <h3 className="text-lg font-semibold text-gray-700">Glissez-déposez vos images ici</h3>
                            <p className="text-gray-500 text-sm">Sélectionnez toutes les images de tous les puits d'un coup.</p>
                        </div>
                        {files.length > 0 && <span className="inline-block bg-green-100 text-green-700 px-3 py-1 rounded-full text-sm font-medium">{files.length} images chargées</span>}
                    </div>
                </div>

                {Object.keys(groups).length > 0 && (
                    <div>
                        <div className="flex justify-between items-end mb-4">
                            <h2 className="text-xl font-bold text-gray-800">Puits détectés ({Object.keys(groups).length})</h2>
                            <button onClick={clearAll} className="text-red-500 text-sm hover:underline flex items-center gap-1"><IconTrash /> Tout effacer</button>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {Object.entries(groups).map(([name, groupFiles]) => {
                                const isSelected = selectedGroups.includes(name);
                                return (
                                    <div key={name} className={`rounded-lg shadow-sm border p-4 transition-all relative ${isSelected ? 'border-blue-500 bg-blue-50 ring-2 ring-blue-200' : 'border-gray-200 bg-white hover:shadow-md'}`}>
                                        <div className="absolute top-4 left-4"><input type="checkbox" checked={isSelected} onChange={() => toggleSelection(name)} className="w-5 h-5 text-blue-600 rounded border-gray-300 focus:ring-blue-500 cursor-pointer"/></div>
                                        <div className="pl-8 mb-2">
                                            <h3 className="font-bold text-lg text-gray-800 truncate" title={name}>{name}</h3>
                                            <span className="bg-gray-100 text-gray-600 text-xs px-2 py-1 rounded">{groupFiles.length} frames</span>
                                        </div>
                                        <div className="text-xs text-gray-500 mb-4 pl-8">Du: {groupFiles[0]?.name.split('_20')[1] || 'Début'}<br/>Au: {groupFiles[groupFiles.length-1]?.name.split('_20')[1] || 'Fin'}</div>
                                        {processing === name ? (
                                            <div className="bg-blue-50 p-3 rounded text-center">
                                                <div className="text-xs text-blue-700 font-medium mb-1">{progress.status}</div>
                                                <div className="w-full bg-blue-200 h-1 rounded-full overflow-hidden"><div className="bg-blue-500 h-full transition-all duration-300" style={{width: `${(progress.current / progress.total) * 100}%`}}></div></div>
                                            </div>
                                        ) : (
                                            <button onClick={() => generateSingle(name)} disabled={!!processing} className={`w-full py-2 rounded-md font-medium text-sm flex items-center justify-center gap-2 transition-colors pl-8 ${processing ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'}`}>
                                                {processing ? '...' : <><IconDownload className="w-4 h-4" /> Télécharger</>}
                                            </button>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}
            </div>

            {selectedGroups.length > 0 && (
                <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-lg p-4 z-50">
                    <div className="max-w-6xl mx-auto flex flex-col md:flex-row items-center justify-between gap-4">
                        <div className="flex-1 w-full overflow-hidden">
                            <h3 className="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2 flex items-center gap-2"><IconGrid className="w-4 h-4" /> Comparateur ({selectedGroups.length})</h3>
                            <div className="flex gap-4 overflow-x-auto pb-4 scrollbar-thin">
                                {selectedGroups.map((name, index) => (
                                    <div key={name} className="flex flex-col gap-1 min-w-[180px] border rounded p-2 bg-gray-50 relative group">
                                        <div className="flex justify-between items-center mb-1">
                                            <span className="text-xs text-gray-400 truncate max-w-[100px]" title={name}>{name}</span>
                                            <button onClick={() => toggleSelection(name)} className="text-red-400 hover:text-red-600"><svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
                                        </div>
                                        <input type="text" value={customLabels[name] || ''} onChange={(e) => handleLabelChange(name, e.target.value)} placeholder="Titre" className="border border-gray-300 rounded px-2 py-1 text-sm outline-none w-full"/>
                                        <div className="flex justify-between mt-2">
                                            <button onClick={() => moveGroup(index, -1)} disabled={index === 0} className={`p-1 rounded ${index === 0 ? 'text-gray-300' : 'text-blue-500 hover:bg-blue-100'}`}><IconArrowLeft /></button>
                                            <span className="text-xs text-gray-400 self-center">{index + 1}</span>
                                            <button onClick={() => moveGroup(index, 1)} disabled={index === selectedGroups.length - 1} className={`p-1 rounded ${index === selectedGroups.length - 1 ? 'text-gray-300' : 'text-blue-500 hover:bg-blue-100'}`}><IconArrowRight /></button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div className="flex items-center gap-4 min-w-[200px] justify-end">
                            {processing && String(processing).startsWith("Comparaison") ? (
                                <div className="text-center w-full">
                                    <div className="text-xs text-blue-600 font-bold mb-1">{progress.status}</div>
                                    <div className="w-full bg-gray-200 h-2 rounded-full overflow-hidden"><div className="bg-blue-600 h-full transition-all" style={{width: `${(progress.current / progress.total) * 100}%`}}></div></div>
                                </div>
                            ) : (
                                <button onClick={generateComparison} disabled={!!processing} className={`px-6 py-3 rounded-lg font-bold text-white shadow-md flex items-center gap-2 whitespace-nowrap ${processing ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}`}>
                                    <IconFilm className="w-5 h-5" /> Générer Vidéo
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}
